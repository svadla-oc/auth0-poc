{"version":3,"sources":["meteor://ðŸ’»app/packages/idmontie_migrations/migrations.js"],"names":[],"mappings":";;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"/packages/idmontie_migrations.js","sourcesContent":["/**\n * Meteor Migration\n *\n * Simple database migrations for meteor\n *\n * @author idmontie\n */\n\n/* global console */\n\nif ( Meteor.isServer ) {\n  var _$ = this;\n\n  // =================\n  // Meteor Migrations\n  // =================\n\n  this.Migrations = {\n    /**\n     * Meteor collection to store data in\n     * TODO settings should dictate what db to use.\n     */\n    warehouse : new Meteor.Collection( 'meteor-migrations' ),\n    /**\n     * Add a migration.  Will run the given migration once and only\n     * once, even when the app is restarted.\n     *\n     * Returns true if a migration of the same name is not already added.\n     * Returns false if otherwise.\n     *\n     * Migration names should be globally unique.\n     *\n     * The order number is an optional parameter that sets what\n     * order the migrations should be run in. Migrations are run\n     * from smallest order number to largest order number.  If an\n     * order number is not provided, the largest order number + 10\n     * is used.\n     *\n     * @param String name Name of the migration\n     * @param Function migrationCallback The function to run once and only once\n     * @param Number order Optional order number\n     * @return boolean\n     */\n    add : function ( name, migrationCallback, rollbackCallback, order ) {\n      'use strict';\n\n      // If we are called with less than 4 arguments, than assume\n      // that we are being called with the following signature:\n      // ( name, migrationCallback, order ) \n      if ( arguments.length < 4 ) {\n        order = rollbackCallback;\n        rollbackCallback = null;\n      }\n\n      var found = false\n\n      for ( var i = 0; i < _$.Migrations.migrations.length; i++ ) {\n        if ( name == _$.Migrations.migrations[i].name ) {\n          found = true\n          break\n        }\n      }\n\n      if ( ! found ) {\n        if ( order == null ) {\n          order = _$.Migrations.largestOrderNumber + 10\n          _$.Migrations.largestOrderNumber = order\n        } else if ( order > _$.Migrations.largestOrderNumber ) {\n          _$.Migrations.largestOrderNumber = order\n        }\n\n        _$.Migrations.migrations.push( {\n          migrationCallback: migrationCallback,\n          rollbackCallback: rollbackCallback,\n          name: name,\n          order: order\n        } )\n\n        return true\n      } else {\n        return false\n      }\n    },\n    /**\n     * Removes the migration from the current queue.\n     * This does NOT remove the migration from the collection of\n     * previously run migrations.\n     *\n     * To remove a migration to allow it to rerun, use removeFromDatabase.\n     *\n     * @param String name Name of the migration\n     */\n    remove : function ( name ) {\n      'use strict';\n\n      for ( var i = 0; i < _$.Migrations.migrations.length; i++ ) {\n        if ( _$.Migrations.migrations[i].name == name ) {\n          delete _$.Migrations.migrations[i];\n        }\n      }\n    },\n    /**\n     * Removes the migration from the database, so that it can be run again.\n     *\n     * @param String name Name of the migration\n     */\n    removeFromDatabase : function ( name ) {\n      'use strict';\n\n      // TODO settings should dictate what db to use\n      _$.Migrations.warehouse.remove( {\n        name : name\n      } )\n    },\n    /**\n     * Changes which function to run when the migration is performed.\n     *\n     * If the migration with the given name has already been run, this will\n     * NOT force a re-run of the migration.  This is only available to override\n     * which migration to run.\n     *\n     * @param String name Name of the migration\n     * @param Function newMigrationCallback The new function to run once and only once\n     */\n    update : function ( name, newMigrationCallback, order ) {\n      'use strict';\n\n      for ( var i = 0; i < _$.Migrations.migrations.length; i++ ) {\n        if ( name == _$.Migrations.migrations[i].name ) {\n          if ( order == null ) {\n            order = _$.Migrations.migrations[i].order\n          } else if ( order > _$.Migrations.largestOrderNumber ) {\n            _$.Migrations.largestOrderNumber = order\n          }\n        }\n\n        _$.Migrations.migrations[i] = {\n          migrationCallback: newMigrationCallback,\n          name: name,\n          order: order\n        }\n      }\n    },\n    /**\n     * Rollback a given migration. The migration will be rerun on start up since\n     * this also removes the migration from the database.\n     *\n     * @param String name The name of the migration to rollback\n     */\n    rollback : function ( name ) {\n      for ( var i = 0; i < _$.Migrations.migrations.length; i++ ) {\n        if ( _$.Migrations.migrations[i].name == name ) {\n          \n          if ( _$.Migrations.migrations[i].rollbackCallback ) {\n            _$.Migrations.migrations[i].rollbackCallback();\n          }\n        }\n      }\n\n      _$.Migrations.removeFromDatabase( name );\n    },\n    /**\n     * Enables console logs for already run migrations.\n     *\n     * @type boolean\n     */\n    verbose : false,\n    /**\n     * Array of migration objects.  Do not use directly.\n     *\n     * Initially empty, no migrations to run\n     *\n     * Object structure:\n     *\n     * - orderNumber\n     * - name\n     * - migrationCallback\n     *\n     * @type Array\n     */\n    migrations : [],\n    /**\n     * Stores the largest order number\n     *\n     * @type Number\n     */\n    largestOrderNumber : 0\n  };\n\n  // ==============\n  // Meteor Startup\n  // ==============\n\n  Meteor.startup( function () {\n    'use strict';\n\n    /*\n     * Migrations are unsorted.  Sort them and do them in order of\n     * smallest to largest order number\n     */\n\n    _$.Migrations.migrations.sort( function ( a, b ) {\n      if ( a.order < b.order ) {\n        return -1;\n      } else if ( a.order > b.order ) {\n        return 1;\n      } else {\n        return 0;\n      }\n    } )\n\n\n    for ( var i = 0; i < _$.Migrations.migrations.length; i++ ) {\n      var migration = _$.Migrations.migrations[i]\n      // Do the migration\n      var pastMigration = _$.Migrations.warehouse.findOne( {\n        name : migration.name\n      } )\n\n      if ( ! pastMigration ) {\n        console.log ( '> Starting ' + migration.name + ' migration.' )\n\n        migration.migrationCallback()\n\n        _$.Migrations.warehouse.insert( {\n          name : migration.name\n        } )\n\n        console.log ( '> Finishing ' + migration.name + ' migration.' )\n      } else {\n        if ( _$.verbose ) {\n          console.log( '> Skipping ' + migration.name + '.' )\n        }\n      }\n    }\n  } )\n}\n"]}